# 设计模式(示例只有部分)

## 1、Singleton 单例模式 

  * 应用场景:
    (1)只需要一个实例
  
## 2、Strategy 策略模式 

  Comparator -- compare(策略模式)
  Comparable -- compareTo

## 3、工厂模式

    任何可以产生对象的方法或者类都可以称之为工厂；
    单例也是一种工厂

  简单工厂
  静态工厂
  工厂方法
  抽象工厂

## 4、门面模式Facade、调停者模式Mediator

解耦

  Mediator：消息中间件
  
  Facade：制作展示，不做内部逻辑

## 5、Decorator 装饰器模式 

  使用聚合代替继承

## 6、Observer 观察者模式 



## 7、Composite 组合模式 

  树状结构专用模式

## 8、flyweight 享元模式 

  重复利用对象（java中的String）
  连接池、线程池

## 9、Proxy 代理模式

  静态代理
  
  动态代理
    jdk : 类必须实现接口
    cglib : 不需要实现接口
    
  AOP 面向切面编程

## 10、iterator 迭代器模式

  容器与容器遍历

## 11、visitor 访问者模式

  在结构不变的情况下，动态改变对于内部元素的动作

## 12、Chain Of Responsibility 责任链模式 


## 13、Builder 
  
  构建复杂对象
    分离复杂对象的构建和表示
    同样的构建过程可以创建不同的表示
    
* 链式编程

## 14、Adapter (Wrapper) 适配器模式
  
  接口转换器

## 15、Bridge 桥接模式 

  双维度扩展
    * 分离抽象与具体
    * 使用聚合方式（桥）连接抽象与具体

## 16、Command 命令模式 
  
  封装命令
  结合cor实现undo
  
  多次undo（与责任链模式结合使用）

## 17、prototype 原型模式(java中自带)

  clone
  实现原型模式需要实现标记型接口Cloneable

## 18、memento 备忘录 与序列化

  记住状态，便于回滚
  
  * 记录快照（瞬时状态）
  * 存盘

## 19、TemplateMethod 模板模式 


## 20、State 状态模式

  根据状态来决定行为
  
## interpreter 解释器模式

  动态脚本解析
  
## 面向对象六大原则
  
  可维护性、可复用性、可扩展性、灵活性
  
  * 单一职责原则，高内聚低耦合
  * 开闭原则，对扩展开放，对修改关闭，抽象化、多态
  * 里氏替换原则，所有使用父类的地方，必须能够透明地使用子类对象
  * 依赖倒置原则，依赖抽象，而不是依赖具体，面向抽象编程
  * 接口隔离原则，每个接口承担独立的角色
  * 迪米特法则尽量不要和陌生人说话